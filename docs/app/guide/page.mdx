# Руководство по использованию

В этом разделе вы узнаете, как использовать `lite-fsm` для создания и управления конечными автоматами в ваших приложениях.

## Основные концепции

Библиотека `lite-fsm` построена вокруг нескольких ключевых концепций:

### Состояния и переходы

Конечный автомат всегда находится в определенном состоянии. Переход между состояниями происходит в результате обработки событий (actions).

### Контекст

Контекст представляет собой объект с данными, связанными с автоматом. При переходе между состояниями контекст может обновляться.

### Эффекты

Эффекты - это функции, которые выполняются при переходе в определенное состояние. Они могут использоваться для выполнения побочных действий, таких как вызов API или обновление UI.

### Менеджер автоматов

`MachineManager` управляет всеми автоматами, обрабатывает переходы состояний и запускает соответствующие эффекты.

## Создание автомата

Автомат создается с помощью функции `createMachine`:

```ts
import { createMachine } from "lite-fsm";

const toggleMachine = createMachine({
  // Конфигурация состояний и переходов
  config: {
    INACTIVE: {
      TOGGLE: "ACTIVE",
    },
    ACTIVE: {
      TOGGLE: "INACTIVE",
    },
  },
  // Начальное состояние
  initialState: "INACTIVE",
  // Начальный контекст
  initialContext: {
    lastToggled: null,
  },
  // Эффекты при переходе в состояния
  effects: {
    ACTIVE: ({ transition }) => {
      console.log("Активировано!");
      // Здесь можно выполнить побочные эффекты
    },
    INACTIVE: ({ transition }) => {
      console.log("Деактивировано!");
      // Здесь можно выполнить побочные эффекты
    },
  },
  // Пользовательский reducer для обработки переходов (опционально)
  reducer: (state, action, options) => {
    // По умолчанию используется стандартный reducer
    // Здесь можно изменить логику обновления состояния и контекста
    return {
      state: options.nextState,
      context: {
        ...state.context,
        lastToggled: new Date(),
      },
    };
  },
});
```

## Управление автоматом через MachineManager

После создания автомата, нужно инициализировать менеджер:

```ts
import { MachineManager } from "lite-fsm";

// Можно создать несколько автоматов и управлять ими через один менеджер
const manager = MachineManager({
  toggle: toggleMachine,
  // другие автоматы ...
});

// Подписка на изменения состояний
manager.onTransition((prevState, nextState) => {
  console.log("Состояние изменилось:", { prevState, nextState });
});

// Вызов перехода
manager.transition({ type: "TOGGLE" });

// Получение текущего состояния и контекста
const { state, context } = manager.getState().toggle;
```

## Внедрение зависимостей

Менеджер позволяет внедрять зависимости, которые будут доступны в эффектах:

```ts
// Создание зависимостей
const dependencies = {
  services: {
    api: {
      fetchData: () => fetch("/api/data").then((r) => r.json()),
    },
    logger: {
      log: (message) => console.log(`[LOG]: ${message}`),
    },
  },
  utils: {
    formatDate: (date) => new Intl.DateTimeFormat().format(date),
  },
};

// Установка зависимостей
manager.setDependencies(dependencies);

// Автомат с использованием зависимостей
const dataMachine = createMachine({
  config: {
    IDLE: {
      FETCH: "LOADING",
    },
    LOADING: {
      FETCH_SUCCESS: "SUCCESS",
      FETCH_ERROR: "ERROR",
    },
    SUCCESS: {
      RESET: "IDLE",
    },
    ERROR: {
      RETRY: "LOADING",
      RESET: "IDLE",
    },
  },
  initialState: "IDLE",
  initialContext: {
    data: null,
    error: null,
    lastUpdated: null,
  },
  effects: {
    // Зависимости доступны в параметрах эффекта
    LOADING: async ({ transition, services, utils }) => {
      try {
        const data = await services.api.fetchData();
        services.logger.log("Данные успешно загружены");
        transition({
          type: "FETCH_SUCCESS",
          payload: {
            data,
            lastUpdated: utils.formatDate(new Date()),
          },
        });
      } catch (error) {
        services.logger.log("Ошибка при загрузке данных");
        transition({
          type: "FETCH_ERROR",
          payload: { error: error.message },
        });
      }
    },
  },
});
```

## Асинхронные эффекты

Эффекты могут быть асинхронными, что позволяет легко интегрировать их с API и другими асинхронными операциями:

```ts
effects: {
  LOADING: async ({ transition, services }) => {
    try {
      // Асинхронная операция
      const result = await services.api.fetchSomething();

      // Передаем данные в контекст через payload
      transition({
        type: "FETCH_SUCCESS",
        payload: { data: result },
      });
    } catch (error) {
      transition({
        type: "FETCH_ERROR",
        payload: { error: error.message },
      });
    }
  };
}
```

## Дополнительные возможности

### Дикие карты (WILDCARD)

Можно использовать специальный символ `*` для обработки любого состояния:

```ts
import { createMachine, WILDCARD } from "lite-fsm";

const machine = createMachine({
  config: {
    STATE_A: {
      EVENT_1: "STATE_B",
    },
    STATE_B: {
      EVENT_2: "STATE_C",
    },
    STATE_C: {
      EVENT_3: "STATE_A",
    },
    // Обработка событий в любом состоянии
    [WILDCARD]: {
      RESET: "STATE_A",
      LOG: null, // null означает, что состояние не меняется
    },
  },
  // ...
});
```

### Создание эффектов с отменой

Библиотека позволяет создавать эффекты с возможностью отмены:

```ts
import { createEffect } from "lite-fsm";

const fetchDataEffect = createEffect({
  // Тип эффекта: "latest" выполняет только последний вызов
  type: "latest",
  effect: async ({ transition, services }) => {
    // Реализация эффекта
    const data = await services.api.fetchData();
    transition({ type: "FETCH_SUCCESS", payload: { data } });
  },
  // Функция для проверки условий отмены
  cancelFn: (deps) => {
    let canceled = false;
    return () => {
      return canceled;
    };
  },
});
```

### Интерактивный пример

Вы можете поэкспериментировать с этим примером прямо здесь:

<CodeSandbox
  sandboxId="stoic-haslett-zt3lz7"
  options={{
    editorHeight: "500px",
    previewHeight: "300px",
    autoResize: true,
  }}
/>

### Использование Sandpack компонента

Также вы можете использовать встроенный редактор кода:

<Sandpack 
  files={{
    "/App.tsx": `import { createMachine, MachineManager } from 'lite-fsm';
import { useState, useEffect } from 'react';

// Создаем простой автомат для тумблера
const toggleMachine = createMachine({
config: {
inactive: {
TOGGLE: 'active'
},
active: {
TOGGLE: 'inactive'
}
},
initialState: 'inactive',
initialContext: {
toggleCount: 0
},
effects: {
// Вызывается при входе в состояние
active: ({ context, updateContext }) => {
updateContext({
toggleCount: context.toggleCount + 1
});
console.log('Activated! Toggle count:', context.toggleCount + 1);
}
}
});

// Создаем менеджер для управления автоматом
const manager = MachineManager({ toggle: toggleMachine });

function App() {
// Локальное состояние для отслеживания состояния автомата
const [state, setState] = useState(manager.getState());

useEffect(() => {
// Подписываемся на изменения состояния
const unsubscribe = manager.onTransition(() => {
setState(manager.getState());
});

    return unsubscribe;

}, []);

const { state: currentState, context } = state.toggle;

return (

<div className="App" style={{ fontFamily: 'system-ui, sans-serif', padding: '20px' }}>
<h1>Toggle FSM Example</h1>

      <div style={{ margin: '20px 0' }}>
        <div>Current state: <strong>{currentState}</strong></div>
        <div>Toggle count: <strong>{context.toggleCount}</strong></div>
      </div>

      <button
        onClick={() => manager.transition({ type: 'TOGGLE' })}
        style={{
          padding: '8px 16px',
          backgroundColor: currentState === 'active' ? '#4CAF50' : '#9E9E9E',
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer'
        }}
      >
        Toggle
      </button>
    </div>

);
}

export default App;`,
    "/index.tsx": `import React, { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import App from "./App";

const root = createRoot(document.getElementById("root"));
root.render(

<StrictMode>
  <App />
</StrictMode>
);` }} options={{
  showConsole: true,
  editorHeight: "400px",
}}
customSetup=
{{
  dependencies: {
    "lite-fsm": "latest",
  },
}}
/>

## Примеры в CodeSandbox

Вы также можете изучить полные примеры проектов в CodeSandbox:

<CodeSandbox
  sandboxId="https://codesandbox.io/p/sandbox/festive-darkness-rx2hwn"
  options={{
    editorHeight: "450px",
    previewHeight: "350px",
    autoResize: true,
  }}
/>
