# API Справочник

В этом разделе приведена документация по всем функциям и типам библиотеки `lite-fsm`.

## Основной модуль

Основной модуль предоставляет функции для создания и управления конечными автоматами.

### createMachine

```ts
createMachine<C, T, E, P = FSMEvent<E, any>, D = {}>(cfg: MachineConfig<C, T, P, D>): Machine<C, T, P, D>
```

Функция для создания конечного автомата.

**Параметры:**

- `cfg`: Объект конфигурации автомата.

**Возвращает:**

Объект автомата.

**Пример:**

```ts
import { createMachine } from "lite-fsm";

const toggleMachine = createMachine({
  config: {
    INACTIVE: {
      TOGGLE: "ACTIVE",
    },
    ACTIVE: {
      TOGGLE: "INACTIVE",
    },
  },
  initialState: "INACTIVE",
  initialContext: {
    lastToggled: null,
  },
});
```

### MachineManager

```ts
MachineManager<M extends Record<string, Machine<any, any, any, any>>>(
  machines: M,
  opts?: {
    middleware?: Middleware<MachinesState<M>, any>[];
    onError?: (err: any) => void;
  }
): MachineManager<M>
```

Функция для создания менеджера автоматов.

**Параметры:**

- `machines`: Объект с автоматами, где ключи - имена автоматов, а значения - объекты автоматов.
- `opts`: (Опционально) Объект с дополнительными опциями.
  - `middleware`: Массив функций middleware для расширения функциональности.
  - `onError`: Обработчик ошибок, возникающих при выполнении эффектов.

**Возвращает:**

Менеджер автоматов.

**Пример:**

```ts
import { MachineManager, createMachine } from "lite-fsm";
import { immerMiddleware } from "lite-fsm/middleware";

const toggleMachine = createMachine({
  // ...конфигурация
});

const counterMachine = createMachine({
  // ...конфигурация
});

// Создание менеджера без дополнительных опций
const simpleManager = MachineManager({
  toggle: toggleMachine,
  counter: counterMachine,
});

// Создание менеджера с middleware и обработчиком ошибок
const advancedManager = MachineManager(
  {
    toggle: toggleMachine,
    counter: counterMachine,
  },
  {
    middleware: [
      immerMiddleware,
      // Пользовательский middleware для логирования
      (api) => (next) => (action) => {
        console.log("Action:", action);
        const result = next(action);
        console.log("New state:", api.getState());
        return result;
      },
    ],
    onError: (error) => {
      console.error("Error in machine effect:", error);
      // Можно отправить ошибку в сервис мониторинга
    },
  },
);
```

#### Методы MachineManager

##### transition

```ts
transition<E extends string, P extends Record<string, any>>(
  action: { type: E; machine?: string; payload?: P }
): void
```

Выполняет переход состояния для указанного (или всех) автоматов.

**Параметры:**

- `action`: Объект действия.
  - `type`: Тип события.
  - `machine`: (Опционально) Имя автомата. Если не указано, действие будет отправлено всем автоматам.
  - `payload`: (Опционально) Полезная нагрузка, которая будет объединена с контекстом.

**Пример:**

```ts
// Отправить событие конкретному автомату
manager.transition({
  type: "TOGGLE",
  machine: "toggle",
  payload: { lastToggled: new Date() },
});

// Отправить событие всем автоматам
manager.transition({ type: "RESET" });
```

##### getState

```ts
getState(): { [K in keyof M]: { state: State<C>; context: T } }
```

Возвращает текущее состояние и контекст всех автоматов.

**Возвращает:**

Объект, в котором ключи - имена автоматов, а значения - объекты с состоянием и контекстом.

**Пример:**

```ts
const state = manager.getState();
console.log(state.toggle.state); // Текущее состояние автомата toggle
console.log(state.counter.context); // Текущий контекст автомата counter
```

##### onTransition

```ts
onTransition(
  callback: (
    prevState: { [K in keyof M]: { state: State<C>; context: T } },
    nextState: { [K in keyof M]: { state: State<C>; context: T } },
    action?: { type: string; machine?: string; payload?: any }
  ) => void
): () => void
```

Подписывает функцию на события перехода состояний.

**Параметры:**

- `callback`: Функция обратного вызова, которая будет вызываться при каждом переходе состояния.

**Возвращает:**

Функция для отмены подписки.

**Пример:**

```ts
const unsubscribe = manager.onTransition((prevState, nextState, action) => {
  console.log("Предыдущее состояние:", prevState);
  console.log("Новое состояние:", nextState);
  console.log("Действие:", action);
});

// Позже, когда подписка больше не нужна
unsubscribe();
```

##### setDependencies

```ts
setDependencies(dependencies: D): void
```

Устанавливает зависимости, которые будут доступны в эффектах.

**Параметры:**

- `dependencies`: Объект с зависимостями.

**Пример:**

```ts
manager.setDependencies({
  services: {
    api: {
      fetchData: async () => {
        const response = await fetch("/api/data");
        return response.json();
      },
    },
  },
  utils: {
    formatDate: (date) => new Intl.DateTimeFormat().format(date),
  },
});
```

##### replaceReducer

```ts
replaceReducer(
  callback: (
    reducer: (state: MachinesState<M>, action: A) => MachinesState<M>
  ) => (state: MachinesState<M>, action: A) => MachinesState<M>
): void
```

Заменяет редьюсер менеджера автоматов. Этот метод используется middleware для модификации поведения обработки состояний.

**Параметры:**

- `callback`: Функция, которая принимает текущий редьюсер и возвращает новый редьюсер.

**Пример:**

```ts
// Пример создания middleware с использованием replaceReducer
const loggingMiddleware = (api) => {
  // Заменяем редьюсер, добавляя логирование
  api.replaceReducer((reducer) => {
    return (state, action) => {
      console.log("Предыдущее состояние:", state);
      console.log("Действие:", action);

      const result = reducer(state, action);

      console.log("Новое состояние:", result);
      return result;
    };
  });

  return (next) => (action) => next(action);
};

// Использование middleware
const manager = MachineManager({ counter: counterMachine }, { middleware: [loggingMiddleware] });
```

##### condition

```ts
condition(
  predicate: (action: A) => boolean
): Promise<boolean>
```

Создает промис, который резолвится, когда переход, удовлетворяющий предикату, происходит в системе. Полезно для создания последовательностей асинхронных операций с ожиданием определенных состояний.

**Параметры:**

- `predicate`: Функция, которая принимает действие и возвращает булево значение.

**Возвращает:**

Промис, который резолвится со значением `true`, когда предикат возвращает `true` для какого-либо действия.

**Пример:**

```ts
// Использование condition в эффекте
const machine = createMachine({
  config: {
    IDLE: {
      START: "PROCESSING",
    },
    PROCESSING: {
      SUCCESS: "SUCCESS",
      ERROR: "ERROR",
    },
    SUCCESS: {
      RESET: "IDLE",
    },
    ERROR: {
      RETRY: "PROCESSING",
      RESET: "IDLE",
    },
  },
  effects: {
    PROCESSING: async ({ transition, condition }) => {
      try {
        // Запуск асинхронной операции
        const processPromise = startLongProcess();

        // Ожидание действия CANCEL до завершения операции
        const raceResult = await Promise.race([
          processPromise,
          condition((action) => action.type === "CANCEL").then(() => ({ cancelled: true })),
        ]);

        // Если операция была отменена
        if (raceResult?.cancelled) {
          transition({ type: "ERROR", payload: { error: "Operation cancelled" } });
          return;
        }

        // Если операция завершилась успешно
        transition({ type: "SUCCESS", payload: { result: raceResult } });
      } catch (error) {
        transition({ type: "ERROR", payload: { error: error.message } });
      }
    },
  },
});
```

### createConfig

```ts
createConfig<C extends Record<string, Record<string, string | null>>>(
  config: C
): C
```

Функция для создания и типизации конфигурации автомата.

**Параметры:**

- `config`: Объект конфигурации автомата.

**Возвращает:**

Тот же объект конфигурации, но с правильной типизацией.

**Пример:**

```ts
import { createConfig, createMachine } from "lite-fsm";

const config = createConfig({
  IDLE: {
    START: "RUNNING",
  },
  RUNNING: {
    PAUSE: "PAUSED",
    STOP: "IDLE",
  },
  PAUSED: {
    RESUME: "RUNNING",
    STOP: "IDLE",
  },
});

const machine = createMachine({
  config,
  initialState: "IDLE",
  // ...
});
```

### createReducer

```ts
createReducer<C, T, P>(
  reducer: (
    state: { state: State<C>; context: T },
    action: P,
    options: { nextState: State<C> | null; config: C }
  ) => { state: State<C>; context: T }
): typeof reducer
```

Функция для создания и типизации пользовательского редьюсера.

**Параметры:**

- `reducer`: Функция редьюсера.

**Возвращает:**

Тот же редьюсер, но с правильной типизацией.

**Пример:**

```ts
import { createReducer, createMachine } from "lite-fsm";

const reducer = createReducer((state, action, options) => {
  const { state: currentState, context } = state;
  const nextState = options.nextState || currentState;

  switch (action.type) {
    case "INCREMENT":
      return {
        state: nextState,
        context: {
          ...context,
          count: context.count + 1,
        },
      };
    case "DECREMENT":
      return {
        state: nextState,
        context: {
          ...context,
          count: context.count - 1,
        },
      };
    default:
      return {
        state: nextState,
        context: {
          ...context,
          ...(action.payload || {}),
        },
      };
  }
});

const machine = createMachine({
  config: {
    // ...
  },
  reducer,
  // ...
});
```

### createEffect

```ts
createEffect<D extends DefaultDeps<any, any, any>, P extends Record<string, any> = {}>(
  opts: {
    type?: EffectType;
    effect: MachineEffect<D, P>;
    cancelFn?: (deps: D) => () => boolean;
  }
): (deps: D, payload: P) => any
```

Функция для создания эффекта с возможностью отмены.

**Параметры:**

- `opts`: Объект с опциями.
  - `type`: (Опционально) Тип эффекта. Может быть `'latest'` для выполнения только последнего вызова.
  - `effect`: Функция эффекта.
  - `cancelFn`: (Опционально) Функция, которая возвращает функцию проверки условия отмены.

**Возвращает:**

Функция эффекта с обработкой отмены.

**Пример:**

```ts
import { createEffect, createMachine } from "lite-fsm";

// Создание эффекта, который будет выполнять только последний вызов
const searchEffect = createEffect({
  type: "latest",
  effect: async ({ transition, services }, { query }) => {
    try {
      const results = await services.api.search(query);
      transition({ type: "SEARCH_SUCCESS", payload: { results } });
    } catch (error) {
      transition({ type: "SEARCH_ERROR", payload: { error: error.message } });
    }
  },
});

const searchMachine = createMachine({
  config: {
    IDLE: {
      SEARCH: "SEARCHING",
    },
    SEARCHING: {
      SEARCH_SUCCESS: "RESULTS",
      SEARCH_ERROR: "ERROR",
    },
    // ...
  },
  effects: {
    SEARCHING: (deps, action) => {
      return searchEffect(deps, action.payload || {});
    },
  },
  // ...
});
```

## Константы

### WILDCARD

```ts
WILDCARD: "*";
```

Специальный символ, используемый для обозначения состояния или события, которое должно соответствовать любому значению.

**Пример:**

```ts
import { createMachine, WILDCARD } from "lite-fsm";

const machine = createMachine({
  config: {
    IDLE: {
      START: "RUNNING",
    },
    RUNNING: {
      STOP: "IDLE",
    },
    // Обработка RESET из любого состояния
    [WILDCARD]: {
      RESET: "IDLE",
    },
  },
  // ...
});
```

## Типы TypeScript

### State

```ts
type State<C> = keyof C;
```

Тип, представляющий состояние автомата.

### FSMEvent

```ts
type FSMEvent<E, P> = { type: E; payload?: P };
```

Тип, представляющий событие автомата.

### CFG

```ts
type CFG<C, T, E> = {
  [K in keyof C]: { [A in E]?: K | null };
};
```

Тип, представляющий конфигурацию автомата.

### MachineConfig

```ts
type MachineConfig<C, T, P, D> = {
  config: C;
  initialState: State<C>;
  initialContext: T;
  effects?: {
    [K in State<C> | typeof WILDCARD]?: (deps: D & DefaultDeps<T, C, P>, action?: P) => any;
  };
  reducer?: (
    state: { state: State<C>; context: T },
    action: P,
    options: { nextState: State<C> | null; config: C },
  ) => { state: State<C>; context: T };
};
```

Тип, представляющий полную конфигурацию автомата.

### Machine

```ts
type Machine<C, T, P, D> = {
  config: C;
  transition: (s: { state: State<C>; context: T }, action: P) => { state: State<C>; context: T };
  onTransition: (cb: Subscriber<State<C>, T>) => () => void;
  invokeEffect: (prevState: State<C>, currentState: State<C>, deps: D & DefaultDeps<T, C, P>) => Promise<any>;
};
```

Тип, представляющий объект автомата.

### MachineManager

```ts
type MachineManager<M> = {
  transition: <E extends string, P extends Record<string, any>>(action: {
    type: E;
    machine?: string;
    payload?: P;
  }) => void;
  getState: () => { [K in keyof M]: { state: any; context: any } };
  onTransition: (
    callback: (
      prevState: { [K in keyof M]: { state: any; context: any } },
      nextState: { [K in keyof M]: { state: any; context: any } },
      action?: { type: string; machine?: string; payload?: any },
    ) => void,
  ) => () => void;
  setDependencies: (dependencies: any) => void;
};
```

Тип, представляющий менеджер автоматов.

## Модуль React

Модуль React предоставляет хуки и компоненты для использования `lite-fsm` в приложениях React.

### FSMProvider

```tsx
<FSMProvider manager={manager}>{children}</FSMProvider>
```

Компонент-провайдер, который делает менеджер автоматов доступным для всех дочерних компонентов через React Context.

**Свойства:**

- `manager`: Объект менеджера автоматов.
- `children`: Дочерние компоненты.

**Пример:**

```tsx
import { FSMProvider } from "lite-fsm/react";
import { manager } from "./store";

function App() {
  return (
    <FSMProvider manager={manager}>
      <Counter />
      <UserProfile />
      {/* Другие компоненты */}
    </FSMProvider>
  );
}
```

### useSelector

```ts
useSelector<S>(
  selector: (state: { [K in keyof M]: { state: any; context: any } }) => S,
  equalityFn?: (a: S, b: S) => boolean
): S
```

Хук для выбора и подписки на часть состояния из менеджера автоматов.

**Параметры:**

- `selector`: Функция, которая принимает состояние и возвращает производную часть этого состояния.
- `equalityFn`: (Опционально) Функция сравнения для определения, изменилось ли выбранное состояние.

**Возвращает:**

Выбранную часть состояния.

**Пример:**

```tsx
import { useSelector } from "lite-fsm/react";

function Counter() {
  // Выбор счетчика из состояния
  const count = useSelector((state) => state.counter.context.count);

  // Выбор нескольких значений
  const { isAuthenticated, username } = useSelector((state) => ({
    isAuthenticated: state.auth.state === "AUTHENTICATED",
    username: state.auth.context.user?.name || "Guest",
  }));

  return (
    <div>
      <p>Count: {count}</p>
      <p>
        User: {username} ({isAuthenticated ? "Authenticated" : "Guest"})
      </p>
    </div>
  );
}
```

### useTransition

```ts
useTransition(): <E extends string, P extends Record<string, any>>(
  action: { type: E; machine?: string; payload?: P }
) => void
```

Хук, который возвращает функцию для отправки действий менеджеру автоматов.

**Возвращает:**

Функция для отправки действий.

**Пример:**

```tsx
import { useSelector, useTransition } from "lite-fsm/react";

function Counter() {
  const count = useSelector((state) => state.counter.context.count);
  const transition = useTransition();

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => transition({ type: "INCREMENT", machine: "counter" })}>Increment</button>
      <button onClick={() => transition({ type: "DECREMENT", machine: "counter" })}>Decrement</button>
      <button onClick={() => transition({ type: "RESET", machine: "counter" })}>Reset</button>
    </div>
  );
}
```

### useManager

```ts
useManager<M extends Record<string, Machine<any, any, any, any>>>(): MachineManager<M>
```

Хук для получения прямого доступа к объекту менеджера автоматов.

**Возвращает:**

Объект менеджера автоматов.

**Пример:**

```tsx
import { useManager } from "lite-fsm/react";
import { useEffect } from "react";

function DebugPanel() {
  const manager = useManager();

  useEffect(() => {
    // Подписка на изменения состояния
    const unsubscribe = manager.onTransition((prevState, nextState) => {
      console.log("Состояние изменилось:", prevState, nextState);
    });

    return unsubscribe;
  }, [manager]);

  return (
    <div>
      <pre>{JSON.stringify(manager.getState(), null, 2)}</pre>
      <button onClick={() => manager.transition({ type: "RESET_ALL" })}>Сбросить все</button>
    </div>
  );
}
```

## Модуль Middleware

Модуль middleware предоставляет функции для создания промежуточного программного обеспечения для расширения функциональности менеджера автоматов.

### Применение middleware

```ts
MachineManager(
  machines: M,
  options: {
    middleware?: Middleware<MachinesState<M>, any>[];
    onError?: (err: any) => void;
  }
): MachineManager<M>
```

Функция `MachineManager` позволяет указать массив middleware через параметр `options.middleware`.

**Параметры:**

- `machines`: Объект с автоматами, где ключи - имена автоматов, а значения - объекты автоматов.
- `options`: Объект с опциями.
  - `middleware`: Массив функций middleware.
  - `onError`: Обработчик ошибок.

**Возвращает:**

Менеджер автоматов с применёнными middleware.

**Пример:**

```ts
import { MachineManager, createMachine } from "lite-fsm";
import { immerMiddleware, devToolsMiddleware } from "lite-fsm/middleware";

// Промежуточное ПО для логирования
const logger = (store) => (next) => (action) => {
  console.log("Действие:", action);
  const result = next(action);
  console.log("Состояние после:", store.getState());
  return result;
};

// Создание машин
const toggleMachine = createMachine({
  // ...конфигурация
});

// Создание менеджера с промежуточным ПО
const manager = MachineManager({ toggle: toggleMachine }, { middleware: [logger, immerMiddleware] });

// Теперь все действия будут логироваться
manager.transition({ type: "TOGGLE" });
```

### Встроенные middleware

#### immerMiddleware

```ts
immerMiddleware: Middleware;
```

Middleware для интеграции с [Immer](https://immerjs.github.io/immer), который позволяет писать иммутабельный код мутативным стилем.

**Пример:**

```ts
import { MachineManager, createMachine } from "lite-fsm";
import { immerMiddleware } from "lite-fsm/middleware";

const manager = MachineManager({ toggle: toggleMachine }, { middleware: [immerMiddleware] });
```

#### devToolsMiddleware

```ts
devToolsMiddleware(options?: { blacklistActions: string[] }): Middleware
```

Middleware для интеграции с [Redux DevTools Extension](https://github.com/reduxjs/redux-devtools), который позволяет отлаживать состояние приложения и переходы между состояниями.

**Параметры:**

- `options`: Объект с параметрами.
  - `blacklistActions`: Массив типов действий, которые не будут отправляться в DevTools.

**Пример:**

```ts
import { MachineManager, createMachine } from "lite-fsm";
import { devToolsMiddleware } from "lite-fsm/middleware";

const manager = MachineManager(
  { counter: counterMachine },
  {
    middleware: [devToolsMiddleware({ blacklistActions: ["TIMER_TICK"] })],
  },
);
```

### Middleware

```ts
type Middleware<S, A> = (api: {
  getState: () => S;
  transition: (action: A) => A;
  replaceReducer: (cb: (reducer: (state: S, action: A) => S) => (state: S, action: A) => S) => void;
  onTransition: (callback: (prevState: S, nextState: S, action?: A) => void) => () => void;
  condition: (predicate: (a: A) => boolean) => Promise<boolean>;
}) => (next: (action: A) => A) => (action: A) => A;
```

Тип, представляющий функцию middleware.

**Пример создания пользовательского middleware:**

```ts
// Middleware для отслеживания производительности
const performanceMiddleware = (store) => (next) => (action) => {
  const start = Date.now();
  const result = next(action);
  const end = Date.now();
  console.log(`Действие ${action.type} выполнено за ${end - start}ms`);
  return result;
};

// Middleware для предотвращения определенных действий
const filterMiddleware = (store) => (next) => (action) => {
  if (action.type === "FORBIDDEN_ACTION") {
    console.warn("Действие FORBIDDEN_ACTION заблокировано");
    return action;
  }
  return next(action);
};

// Использование пользовательских middleware
const manager = MachineManager({ app: appMachine }, { middleware: [performanceMiddleware, filterMiddleware] });
```
